"""DataUpdateCoordinator for Sharp COCORO Air."""
from __future__ import annotations

import asyncio
import copy
import logging

from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant
from homeassistant.exceptions import ConfigEntryAuthFailed, HomeAssistantError
from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed

from .api import SharpAPI, SharpApiError, SharpAuthError, SharpConnectionError
from .const import CONF_EMAIL, CONF_PASSWORD, DOMAIN, OPERATION_MODES, SCAN_INTERVAL

STARTUP_RETRIES = 3
STARTUP_RETRY_DELAY = 10

_LOGGER = logging.getLogger(__name__)


class SharpCocoroAirCoordinator(DataUpdateCoordinator[dict[str, dict]]):
    """Coordinator that polls Sharp cloud API for device data.

    self.data maps device_id (str) -> device dict from SharpAPI.get_devices().
    """

    config_entry: ConfigEntry

    def __init__(self, hass: HomeAssistant, config_entry: ConfigEntry) -> None:
        super().__init__(
            hass,
            _LOGGER,
            name=DOMAIN,
            config_entry=config_entry,
            update_interval=SCAN_INTERVAL,
        )
        self.api = SharpAPI(
            config_entry.data[CONF_EMAIL],
            config_entry.data[CONF_PASSWORD],
        )

    async def _async_setup(self) -> None:
        """Perform initial login sequence (runs once during first refresh).

        Retries on transient connection errors during HA startup when
        DNS/network may not be ready yet.
        """
        last_err: Exception | None = None
        for attempt in range(1, STARTUP_RETRIES + 1):
            try:
                await self.hass.async_add_executor_job(self.api.full_init)
                return
            except SharpAuthError as err:
                raise ConfigEntryAuthFailed("Sharp login failed") from err
            except (SharpConnectionError, SharpApiError) as err:
                last_err = err
                if attempt < STARTUP_RETRIES:
                    _LOGGER.warning(
                        "Sharp cloud init attempt %d/%d failed: %s, retrying in %ds",
                        attempt, STARTUP_RETRIES, err, STARTUP_RETRY_DELAY,
                    )
                    await asyncio.sleep(STARTUP_RETRY_DELAY)
        raise UpdateFailed(f"Cannot connect to Sharp cloud: {last_err}") from last_err

    async def _async_update_data(self) -> dict[str, dict]:
        """Fetch device data from Sharp cloud API."""
        try:
            devices = await self.hass.async_add_executor_job(self.api.get_devices)
        except SharpAuthError:
            # Session expired â€” attempt automatic re-login
            _LOGGER.info("Sharp session expired, attempting re-login")
            try:
                await self.hass.async_add_executor_job(self.api.full_init)
                devices = await self.hass.async_add_executor_job(self.api.get_devices)
            except SharpAuthError as err:
                raise ConfigEntryAuthFailed("Re-login failed") from err
            except SharpConnectionError as err:
                raise UpdateFailed(
                    f"Error communicating with Sharp cloud: {err}"
                ) from err
        except SharpConnectionError as err:
            raise UpdateFailed(
                f"Error communicating with Sharp cloud: {err}"
            ) from err

        return {str(dev["device_id"]): dev for dev in devices}

    async def _async_control(self, fn, *args) -> None:
        """Run a control command with error handling."""
        try:
            await self.hass.async_add_executor_job(fn, *args)
        except SharpAuthError as err:
            raise ConfigEntryAuthFailed("Session expired") from err
        except (SharpConnectionError, SharpApiError) as err:
            raise HomeAssistantError(f"Command failed: {err}") from err

    def _optimistic_update(self, device_id: str, **props) -> None:
        """Apply optimistic state update and notify entities immediately.

        The cloud API has a delay before reflecting state changes,
        so we update coordinator.data in-place with the expected values.
        """
        data = copy.deepcopy(self.data)
        if device_id in data:
            data[device_id]["properties"].update(props)
            self.async_set_updated_data(data)

    async def async_power_on(self, device: dict) -> None:
        """Turn device on."""
        await self._async_control(self.api.power_on, device)
        self._optimistic_update(str(device["device_id"]), power="on")

    async def async_power_off(self, device: dict) -> None:
        """Turn device off."""
        await self._async_control(self.api.power_off, device)
        self._optimistic_update(str(device["device_id"]), power="off")

    async def async_set_mode(self, device: dict, mode: str) -> None:
        """Set operation mode."""
        await self._async_control(self.api.set_mode, device, mode)
        display = OPERATION_MODES.get(mode, mode)
        self._optimistic_update(str(device["device_id"]), operation_mode=display)

    async def async_set_humidify(self, device: dict, on: bool) -> None:
        """Toggle humidification."""
        await self._async_control(self.api.set_humidify, device, on)
        self._optimistic_update(str(device["device_id"]), humidify=on)
